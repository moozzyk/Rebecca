<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>RebeccaAIML: NetworkAimlFacade Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacerebecca.html">rebecca</a>::<a class="el" href="namespacerebecca_1_1impl.html">impl</a>::<a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a></div>
<h1>NetworkAimlFacade Class Reference</h1><!-- doxytag: class="rebecca::impl::NetworkAimlFacade" -->Facade to manage the memory allocation and deallocation of concrete objects that have publicly exposed interfaces as well as provide get'ers to the concrete objects using their exposed interfaces.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_network_aiml_facade_8h-source.html">NetworkAimlFacade.h</a>&gt;</code>
<p>

<p>
<a href="classrebecca_1_1impl_1_1_network_aiml_facade-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classrebecca_1_1impl_1_1_network_graph_builder.html">NetworkGraphBuilder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html#90ba25e302fa07c2823e4c971df2c749">getNetworkGraphBuilder</a> ()  throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the constructed <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> object from NetworkAimlFacade's constructor.  <a href="#90ba25e302fa07c2823e4c971df2c749"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html#dc080f0af3560849268a8d3193e4a3b5">NetworkAimlFacade</a> (int argc, char *argv[])  throw (NetworkException &amp;, Exception &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs the facade and all the concrete objects to the interfaces that have get'ers.  <a href="#dc080f0af3560849268a8d3193e4a3b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html#86107594327f3a001230df9802cd4422">operator delete</a> (void *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All delete's will be handled through this dll.  <a href="#86107594327f3a001230df9802cd4422"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html#205ed048fdf5259c2e8e0cb60ee8f719">operator new</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All new's will be handled through this dll.  <a href="#205ed048fdf5259c2e8e0cb60ee8f719"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html#5c43dc3a4fe0bb0455cbe021a7cc7b6f">~NetworkAimlFacade</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the facade and all the concrete objects to the interfaces that have get'ers.  <a href="#5c43dc3a4fe0bb0455cbe021a7cc7b6f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html#501b6321561bfbb6d97397ca6b4f6beb">NetworkAimlFacade</a> (const <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a> &amp;networkAimlFacade)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The copy constructor.  <a href="#501b6321561bfbb6d97397ca6b4f6beb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html#8aa07daf250871650712844890f4ec32">operator=</a> (const <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a> &amp;networkAimlFacade)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The assignment operator.  <a href="#8aa07daf250871650712844890f4ec32"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classrebecca_1_1impl_1_1_network_graph_builder.html">NetworkGraphBuilder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html#a08359ae9d09ff13ab3554c69a6632f6">m_graphBuilder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> pointer.  <a href="#a08359ae9d09ff13ab3554c69a6632f6"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Facade to manage the memory allocation and deallocation of concrete objects that have publicly exposed interfaces as well as provide get'ers to the concrete objects using their exposed interfaces. 
<p>
<a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> manages the memory for the <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> object. When <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> is instantiated it creates the <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> concrete implementation with a "new" and stores it inside of its pointer to the <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> interface, m_graphBuilder. When <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> is destroyed it in turn destroys the <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> object through this same pointer.<p>
This indirection is needed since <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> is an interface and users cannot directly instantiate it without access to a concrete implementation.<p>
Since <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> creates and deletes the <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> object from the heap with a "new", the memory management stays inside of the dll. This is a requirement for "dll memory boundary safety". <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="dc080f0af3560849268a8d3193e4a3b5"></a><!-- doxytag: member="rebecca::impl::NetworkAimlFacade::NetworkAimlFacade" ref="dc080f0af3560849268a8d3193e4a3b5" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a>           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>argv</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="classrebecca_1_1impl_1_1_network_exception.html">NetworkException</a> &amp;, <a class="el" href="classrebecca_1_1impl_1_1_exception.html">Exception</a> &amp;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs the facade and all the concrete objects to the interfaces that have get'ers. 
<p>
Underneath the covers the constructor creates a factory and from that factor creates the <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> concrete representation and stores it in the m_graphBuilder pointer. Pass in your argc and argv from your main() to this constructor so it can parse any commands it might want. If you don't have access to your arguments from main() you can "fake" it by passing in 1 to argc, and a string with the name of your program to argv.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>argc</em>&nbsp;</td><td>Pass this from your main()</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>Pass this from your main()</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classrebecca_1_1impl_1_1_network_exception.html" title="If a network exception of any type occurs this exception will be thrown.">NetworkException</a></em>&nbsp;</td><td>If it cannot contact the server upon construction to make the initial connection it will throw a network exception with the message of why it cannot contact the server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classrebecca_1_1impl_1_1_exception.html" title="Base Exception class where all AIML exceptions are derived from.">Exception</a></em>&nbsp;</td><td>If an underlying method throws an exception, it will be wrapped and thrown as a <a class="el" href="classrebecca_1_1impl_1_1_exception.html" title="Base Exception class where all AIML exceptions are derived from.">Exception</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5c43dc3a4fe0bb0455cbe021a7cc7b6f"></a><!-- doxytag: member="rebecca::impl::NetworkAimlFacade::~NetworkAimlFacade" ref="5c43dc3a4fe0bb0455cbe021a7cc7b6f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the facade and all the concrete objects to the interfaces that have get'ers. 
<p>
Underneath the covers it deletes the <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> and its respective factory which created it. 
</div>
</div><p>
<a class="anchor" name="501b6321561bfbb6d97397ca6b4f6beb"></a><!-- doxytag: member="rebecca::impl::NetworkAimlFacade::NetworkAimlFacade" ref="501b6321561bfbb6d97397ca6b4f6beb" args="(const NetworkAimlFacade &amp;networkAimlFacade)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>networkAimlFacade</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The copy constructor. 
<p>
For now, I am not allowing this to be invoked. In the future, if I do, it will more than likely be a shallow copy since it could be potentially expensive to do a deep copy of the <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>networkAimlFacade</em>&nbsp;</td><td>The standard second reference </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="90ba25e302fa07c2823e4c971df2c749"></a><!-- doxytag: member="rebecca::impl::NetworkAimlFacade::getNetworkGraphBuilder" ref="90ba25e302fa07c2823e4c971df2c749" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrebecca_1_1impl_1_1_network_graph_builder.html">NetworkGraphBuilder</a>&amp; getNetworkGraphBuilder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the constructed <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> object from NetworkAimlFacade's constructor. 
<p>
The <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> object and memory is constructed in the <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> constructor and destroyed in the <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> destructor. DO NOT try to delete <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> yourself. Instead let <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> auotmagically handle the construction and deletion of <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> constructed in the <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> constructor.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td>exceptions will be thrown. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="86107594327f3a001230df9802cd4422"></a><!-- doxytag: member="rebecca::impl::NetworkAimlFacade::operator delete" ref="86107594327f3a001230df9802cd4422" args="(void *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All delete's will be handled through this dll. 
<p>
This is required for dll boundary safety. Instead of allowing the compiler to choose if it wants to inline this we have made it so that it cannot. If we let the compiler choose to inline or not inline this and the "new operator" we can run into dll boundary issues. The issue would be that the compiler would inline one and not the other. Thus, your executable with its own heap would allocate/delete and this dll would do the other. That's a dll boundary safety violation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pointer to an instance of this object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="205ed048fdf5259c2e8e0cb60ee8f719"></a><!-- doxytag: member="rebecca::impl::NetworkAimlFacade::operator new" ref="205ed048fdf5259c2e8e0cb60ee8f719" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All new's will be handled through this dll. 
<p>
This is required for dll boundary safety. Instead of allowing the compiler to choose if it wants to inline this we have made it so that it cannot. If we let the compiler choose to inline or not inline this and the "delete operator" we can run into dll boundary issues. The issue would be that the compiler would inline one and not the other. Thus, your executable with its own heap would allocate/delete and this dll would do the other. That's a dll boundary safety violation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size to allocate an instance of this object with.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An instance of this object </dd></dl>

</div>
</div><p>
<a class="anchor" name="8aa07daf250871650712844890f4ec32"></a><!-- doxytag: member="rebecca::impl::NetworkAimlFacade::operator=" ref="8aa07daf250871650712844890f4ec32" args="(const NetworkAimlFacade &amp;networkAimlFacade)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a>&amp; operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html">NetworkAimlFacade</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>networkAimlFacade</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The assignment operator. 
<p>
For now, I am not allowing a copy to be made. In the future, if I do, it will more than likely be a shallow copy since it could be potentially expensive to do a deep copy of the <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>networkAimlFacade</em>&nbsp;</td><td>The standard second reference. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="a08359ae9d09ff13ab3554c69a6632f6"></a><!-- doxytag: member="rebecca::impl::NetworkAimlFacade::m_graphBuilder" ref="a08359ae9d09ff13ab3554c69a6632f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrebecca_1_1impl_1_1_network_graph_builder.html">NetworkGraphBuilder</a>* <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html#a08359ae9d09ff13ab3554c69a6632f6">m_graphBuilder</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> pointer. 
<p>
Use NetworkAimlFacade::getGraphBuilder to obtain a reference to this. The <a class="el" href="classrebecca_1_1impl_1_1_graph_builder.html" title="This is the interface from which all AIML action operations will take place.">GraphBuilder</a> object is constructed in the constructor of <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> and deleted in the destructor of <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a>. DO NOT try to delete this yourself. Let <a class="el" href="classrebecca_1_1impl_1_1_network_aiml_facade.html" title="Facade to manage the memory allocation and deallocation of concrete objects that...">NetworkAimlFacade</a> handle the memory of this for "dll memory boundary safety". 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>C:/rebecca/include/rebecca/<a class="el" href="_network_aiml_facade_8h-source.html">NetworkAimlFacade.h</a></ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Aug 27 12:27:00 2007 for RebeccaAIML by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
